\documentclass[12pt]{article}

\usepackage{vmargin}
\usepackage{setspace}
\usepackage[ruled, linesnumbered, french, onelanguage]{algorithm2e}
\usepackage{amsmath, amsthm, amssymb, amsfonts}
\usepackage{enumitem}
\usepackage[utf8]{inputenc}

\title{Devoir 1}
\author{Jérémy Bouchard}
\date{\today}

\begin{document}

  \begin{titlepage}
    \doublespacing
    \centering

    UNIVERSITÉ DU QUÉBEC À CHICOUTIMI \\

    \vspace{4.7cm}

    DEVOIR 1 \\

    \vspace{4.7cm}

    PAR \\
    JÉRÉMY BOUCHARD (BOUJ08019605) \\
    ALEXANDRE LAROUCHE (LARA04119705) \\
    JEAN-PHILIPPE SAVARD (SAVJ04079609) \\
    ALEXIS VALOTAIRE (VALA09129509) \\

    \vspace{4.7cm}

    DEVOIR PRÉSENTÉ À \\
    M. FRANÇOIS LEMIEUX \\
    DANS LE CADRE DU COURS D'ALGORITHMIQUE (8INF433)

  \end{titlepage}

  \newpage

  \noindent \textit{Note :} Le code source \LaTeX est disponible à l'URL
  suivant : \\

  https://github.com/Mukki/algo-devoir-1

  \newpage

  \pagenumbering{arabic}
  \onehalfspacing

  \section*{Question 1}

    \begin{enumerate}[label=(\alph*)]
      \item \[ 4 ^ {log_2 n} \in \omega 4 ^ {log_4 n} \]
      \item \[ (n + 1) ^ {2} \in \Theta (n ^ 2) \]
      \item \[ 2 ^ {n + 1} \in \Theta (2 ^ n) \]
      \item \[ n! \in o (n + 1)! \]
      \item \[ 2 ^ n \in \Theta (4 ^ {n / 2}) \]
      \item \[ n*log_2(n) \in o (n ^ 2 - n) \]
      \item \[ (log_2(n)) ^ 2 \in \omega (log_2(n^2)) \]
      \item \[ {1 \over 2} ^ {n} \in o (1) \]
      \item \[ 2^{100} \in \Theta(2) \]
      \item \[ log_2(n^2) \in \Theta log_4(n) \]
    \end{enumerate}

  \newpage

  \section*{Question 2}
  \subsection*{(a)}

    Il est possible d'exprimer le pseudo-code de l'algorithme décrit dans
    l'énoncé de la question 2. Il est également possible de constater qu'il
    s'agit de l'algorithme du tri par selection. Celui-ci ce décrit de cette
    façon : \newline

    \begin{algorithm}[H]
      \KwData{\( T[1 \cdot\cdot\cdot  n] \)}
      \KwResult{\( T[1 \cdot\cdot\cdot  n] \) (Trié)}
        \For{\( j \gets 1 $ \KwTo $ n - 1 \)}{
          \( petit \gets j \)\\
          \For{\( i \gets j + 1 \) \KwTo \( n \)}{
            \If{\( T[i] < T[petit]\ \)}{
              \( petit \gets i \)\
            }
          }
          \( T[j] \leftrightarrow T[petit] \)
        }
      \caption{Pseudo-code du numéro 2}
    \end{algorithm}

  \subsection*{(b)}

    Il est possible de calculer le temps d'exécution de cette algorithme
    facilement. En effet, pour chaque élément du tableau il est necessaire de
    parcourir le reste du tableau moins les éléments déjà triés. Donc, pour la
    première itération, il est nécessaire de réaliser \( (n - 1) \)
    comparaisons. Pour la deuxième itération, cela sera \( (n - 2) \) itérations
    et ainsi de suite jusqu'à ce qu'il ne reste que une seule valeur à trier. Il
    est donc possible de formaliser le temps d'exécution de cette manière :

    \[ (n - 1) + (n - 2) + (n - 3) + ... + 1 = \sum _ {i=1} ^ {n - 1} i \]

    \noindent Il ne reste qu'à trouver l'ordre de
    \( \sum _ {i=1} ^ {n - 1} i \). \newpage

    \begin{proof}[Temps d'exécution de l'algorithme de tri]
      \begin{align*}
        S   &= \sum _ {i=1} ^ {n - 1} i \\
            &= (n - 1) + (n - 2) + (n - 3) + ... + 1 \\
        2S  &= (n - 1) + (n - 2) + (n - 3) + ... + 1 \\
            &\qquad\,\, + 1 \qquad\;\:\, + 2 \qquad\;\:\, + 3 \;+ ... + (n - 1) \\
            &= \underbrace{(n + n + n + ... + n)}_\textrm{\( (n - 1) \) fois} \\
            &= (n - 1)(n) \\
        S   &= \frac{n(n - 1)}{2} \\
            &= \frac{1}{2}n^2 - \frac{1}{2}n
      \end{align*}
      \( D'o\grave{u} \ \mathcal{O}(n^2) \)
    \end{proof}

  \newpage

  \section*{Question 3}
  Pour prouver cette égalité, il est nécessaire d'utiliser la definition
  formelle de la notation grand \( \mathcal{O} \). \newline

  \noindent Pour prouver que
  \( \mathcal{O}({max\{f(n), g(n)\}}) = \mathcal{O}(f(n) + g(n)) \), on doit
  donc prouver que n'importe quelle fonction apartenant à un ensemble appartient
  aussi à l'autre ensemble. \\

  \begin{proof}[Preuve]
    \noindent \\ Notons une fonction : \[ S(n) \in \mathcal{O}(f(n) + g(n)) \] \\

    \noindent Notons aussi les deux relations suivantes :
    \[ f(n) + g(n) = min\{f(n), g(n)\} + max\{f(n), g(n)\} \]
    \[ max\{f(n), g(n)\} \leq f(n) + g(n) \leq 2 * max\{f(n), g(n)\} \] \\

    \noindent Il est possible d'utiliser la définition formelle pour écrire :
    \begin{align*}
      | S(n) |  &\leq c * (f(n) + g(n)), n > n_1 \\
                &\leq c * 2 * max\{f(n), g(n)\}, n > n_1 &\text{grâce aux relations} \\
                &\leq k * max\{f(n), g(n)\}, n > n_1 \\
                & n_1 = n, k = 2 * c \text{, (n choisi assez grand)} \\
    \end{align*}

    \noindent D'où :
    \( S(n) \in \mathcal{O}({max\{f(n), g(n)\}}) \)
  \end{proof}

  \newpage

  \noindent \newline Pour compléter la preuve, la preuve doit aussi être faite
  dans la direction contraire. \newline

  \begin{proof}[Preuve]
    \noindent \\ Notons une fonction :
    \[ S(n) \in \mathcal{O}({max\{f(n), g(n)\}}) \]

    \noindent Notons toujours, encore une fois, les deux relations suivantes :
    \[ f(n) + g(n) = min\{f(n), g(n)\} + max\{f(n), g(n)\} \]
    \[ max\{f(n), g(n)\} \leq f(n) + g(n) \leq 2 * max\{f(n), g(n)\} \] \\

    \noindent Il est possible d'utiliser la définition formelle pour écrire :
    \begin{align*}
      | S(n) |  &\leq c * max\{f(n), g(n)\}, n > n_1 \\
                &\leq c * f(n) + g(n), n > n_1 &\text{grâce aux relations} \\
                & n_1 = n, k = 2 * c \text{, (n choisi assez grand)} \\
    \end{align*}

    \noindent D'où :
    \( S(n) \in \mathcal{O}(f(n) + g(n)) \)
  \end{proof}

  \newpage

  \section*{Question 4}
	\subsection*{Temps d'exécution}
    Pour déterminer le temps d'exécution de l'algorithme tel qu'écrit dans l'
    énoncé, il faut avant tout analyser ligne par ligne le pseudo-code. Voici
    donc l'analyse ligne par ligne. \newline

    Ligne 1 : \( d = 0 \) \newline
    Une affectation en informatique se fait en un temps constant
    \( \mathcal{O}(1) \). \newline

    Ligne 2 : tant que \( (X > Y) \) faire \( \{ ... \} \) \newline
    L'analyse de cette ligne est beaucoup plus difficile à faire, puisque nous
	  ne savons pas comment la condition sortie est modifiée. Nous le saurons au
    moment de l'analyse du contenu de la boucle. \newline

  	Avec l'analyse du contenu de la boucle, on découvre qu'elle est exécutée
  	\( n \) fois, basée sur la différence de \( X \) et \( Y \). Ainsi, on peut
    conclure qu'elle est exécutée en un temps linéaire \( \mathcal{O}(n) \).
    \newline

    Ligne 3 : \( Soustraction(X, Y) \) \newline
    Il est mentionné dans l'énoncé que cette fonction est exécuté en un temps
	  linéaire \( \mathcal{O}(n) \). \newline

    Ligne 4 : \( d = d + 1 \) \newline
    Une affectation et une addition en informatique se font en un temps constant
    \( \mathcal{O}(1) \). \newline

    Ligne 5 : return \( d \) \newline
  	Un retour en informatique se fait en un temps constant
    \( \mathcal{O}(1) \). \newline

    \noindent Ainsi, il est possible de savoir que :
    \begin{enumerate}
      \item Le temps d'exécution du contenu de la boucle est de \( n + 1 \);
      \item Le contenu de la boucle est exécuté `n` fois, donc \( n(n + 1) \);
      \item Le reste de l'algorithme est en temps constant, donc
       \( n(n + 1) + 1 \).
    \end{enumerate}

    \noindent En distribuant le tout, nous avons \( n ^ 2 + n + 1 \). Donc le
    temps d'exécution est de l'ordre de \( \mathcal{O}(n^2) \).

  \subsection*{Efficacité de l'algorithme}
   	Est-ce que l'algorithme est efficace? La réponse est non. En effet, avec
   	l'analyse du temps d'exécution fait précédement, nous avons déterminé
   	que dans le pire des cas, le temps d'exécution est de l'ordre
   	de \( \mathcal{O}(n^2) \). \newline

   	\noindent Bien qu'un algorithme de cet ordre est généralement acceptable,
   	il est mentionné dans l'énoncé que les variables X et Y sont de grands
   	entiers. On peut conclure que le pire des cas se produira relativement
   	souvent à l'exécution de l'algorithme, ce qui n'est pas vraiment
    acceptable. \newline

    \noindent Pour améliorer l'algorithme, il faudrait que la fonction
    \( Soustraction(X, Y) \) soit exectuable dans un temps constant au lieu d'un
    temps linéaire, ce qui réduirait le temps d'exécution dans l'ordre de
    \( \mathcal{O}(n) \), ce qui serait beaucoup plus acceptable avec de grandes
    valeurs d'entiers. Il serait possible de le faire en remplacant la ligne
    avec \( X - Y \).

  \newpage

  \section*{Question 5}
  	\subsection*{a)}

  	  \subsubsection*{Temps d'exécution de la fonction fib2 dans le pire des cas :}

  	    \noindent \textbf{Ligne 1 :} \( int \: i = 1 \) \newline
        Une affectation en informatique se fait en un temps constant
        \( \mathcal{O}(1) \). \newline
		\textbf{S'exécute 1 fois.} \newline

        \noindent \textbf{Ligne 2 :} \( int \: j = 0 \) \newline
        Une affectation en informatique se fait en un temps constant
        \( \mathcal{O}(1) \). \newline
		\textbf{S'exécute 1 fois.} \newline

        \noindent \textbf{Ligne 3 :}  \( for\: (\:int \: k=1;k<=n;k++) \{ \cdots \} \: \) \newline
        Une boucle \textit{for} de cette forme se fait en temps linéaire
        \( \mathcal{O}(n) \). \newline
        \textbf{S'exécute n fois.} \newline

        \noindent \textbf{Ligne 4 :} \( j=j+i \) \newline
        Une affectation et une addition en informatique se font en un temps constant, \newline
        cependant le fait qu'elle se trouve dans une boucle \textit{for} la rend linéaire
        \( \mathcal{O}(n) \). \newline
		\textbf{S'exécute n-1 fois.} \newline

        \noindent \textbf{Ligne 5 :} \( i = j-i \) \newline
  	    Une affectation et une addition en informatique se font en un temps constant, \newline
        cependant le fait qu'elle se trouve dans une boucle \textit{for} la rend linéaire
        \( \mathcal{O}(n) \). \newline
		\textbf{S'exécute n-1 fois.} \newline

        \noindent \textbf{Ligne 6 :} \( return \: j \) \newline
  	    Un retour en informatique se fait en un temps constant
        \( \mathcal{O}(1) \). \newline
        \textbf{S'exécute 1 fois.} \newline

        \noindent Ainsi, il est possible de savoir que :
	    \begin{align*}
	       T(n) &= \mathcal{O}(1)+\mathcal{O}(1)+\mathcal{O}(n)+\mathcal{O}(n)+\mathcal{O}(n)+\mathcal{O}(1) \\
	   	   &= \mathcal{O}(1+1+n+n+n+1) \\
	       &= \mathcal{O}(n)
	    \end{align*}

	  \newpage

      \subsubsection*{Temps d'exécution de la fonction fib3 dans le pire des cas :}

  	    \noindent \textbf{Ligne 1 :} \( int \: i = 1 \) \newline
        Une affectation en informatique se fait en un temps constant
        \( \mathcal{O}(1) \). \newline
        \textbf{S'exécute 1 fois.} \newline

        \noindent \textbf{Ligne 2 :} \( int \: j = 0 \) \newline
        Une affectation en informatique se fait en un temps constant
        \( \mathcal{O}(1) \). \newline
        \textbf{S'exécute 1 fois.} \newline

        \noindent \textbf{Ligne 3 :} \( int \: k = 0 \) \newline
        Une affectation en informatique se fait en un temps constant
        \( \mathcal{O}(1) \). \newline
 		\textbf{S'exécute 1 fois.} \newline

        \noindent \textbf{Ligne 4 :} \( int \: h = 1 \) \newline
        Une affectation en informatique se fait en un temps constant
        \( \mathcal{O}(1) \). \newline
		\textbf{S'exécute 1 fois.} \newline

        \noindent \textbf{Ligne 5 :} \( while \: (n>0) \{ \cdots \} \) \newline
        Dans le pire des cas, n vaudra \( 2^k - 1 \) où \(k \in \mathbb{N} \), donc de cette manière nous         savons qu'il est question d'un logarithmique.
        \( \mathcal{O}(log \: n) \). \newline
		\textbf{S'exécute log(n) fois.} \newline

        \noindent \textbf{Ligne 6 :}  \( if \: (n\%2)\{ \cdots \} \) \newline
        Une condition se fait en un temps constant, par contre le fait qu'elle se situe dans un \textit{while} fait en sorte que le temps constant va être multiplié par le temps \( \mathcal{O}(log \: n) \) de la boucle. En effet, en étant en pire cas, cette condition se doit d'être vrai en tout temps.
        \( \mathcal{O}(1)*\mathcal{O}(log \: n) \). \newline
		\textbf{S'exécute log(n)-1 fois.} \newline

        \noindent \textbf{Ligne 7 :} \( int \: t = j*h \) \newline
        Une affectation et une addition en informatique se font en un temps constant, cependant le fait qu'elle se trouve dans une boucle \textit{while} fait en sorte qu'elle se multiplie avec le temps d'exécution de cette dernière.
        \( \mathcal{O}(1)*\mathcal{O}(log \: n) \). \newline
		\textbf{S'exécute log(n)-1 fois.} \newline

        \noindent \textbf{Ligne 8 :} \( j = i*h + j*k + t \) \newline
  	    Une affectation et une addition en informatique se font en un temps constant, cependant le fait qu'elle se trouve dans une boucle \textit{while} fait en sorte qu'elle se multiplie avec le temps d'exécution de cette dernière.
        \( \mathcal{O}(1)*\mathcal{O}(log \: n) \). \newline
 		\textbf{S'exécute log(n)-1 fois.} \newline

        \noindent \textbf{Ligne 9 :} \( i = i*k + t; \) \newline
  	    Une affectation et une addition en informatique se font en un temps constant, cependant le fait qu'elle se trouve dans une boucle \textit{while} fait en sorte qu'elle se multiplie avec le temps d'exécution de cette dernière.
        \( \mathcal{O}(1)*\mathcal{O}(log \: n) \). \newline
		\textbf{S'exécute log(n)-1 fois.} \newline

        \noindent \textbf{Ligne 10 :} \( int \: t = h*h \) \newline
  	    Une affectation et une addition en informatique se font en un temps constant, cependant le fait qu'elle se trouve dans une boucle \textit{while} fait en sorte qu'elle se multiplie avec le temps d'exécution de cette dernière.
        \( \mathcal{O}(1)*\mathcal{O}(log \: n) \). \newline
        \textbf{S'exécute log(n)-1 fois.} \newline

        \noindent \textbf{Ligne 11 :} \( h = 2*k*h + t \) \newline
  	    Une affectation et une addition en informatique se font en un temps constant, cependant le fait qu'elle se trouve dans une boucle \textit{while} fait en sorte qu'elle se multiplie avec le temps d'exécution de cette dernière.
        \( \mathcal{O}(1)*\mathcal{O}(log \: n) \). \newline
        \textbf{S'exécute log(n)-1 fois.} \newline

        \noindent \textbf{Ligne 12 :} \( k = k*k + t \) \newline
  	    Une affectation et une addition en informatique se font en un temps constant, cependant le fait qu'elle se trouve dans une boucle \textit{while} fait en sorte qu'elle se multiplie avec le temps d'exécution de cette dernière.
        \( \mathcal{O}(1)*\mathcal{O}(log \: n) \). \newline
        \textbf{S'exécute log(n)-1 fois.} \newline

        \noindent \textbf{Ligne 13 :} \( n = n/2 \) \newline
  	    Une affectation et une addition en informatique se font en un temps constant, cependant le fait qu'elle se trouve dans une boucle \textit{while} fait en sorte qu'elle se multiplie avec le temps d'exécution de cette dernière.
        \( \mathcal{O}(1)*\mathcal{O}(log \: n) \). \newline
        \textbf{S'exécute log(n)-1 fois.} \newline

        \noindent \textbf{Ligne 14 :} \( return \: j \) \newline
  	    Un retour en informatique se fait en un temps constant
        \( \mathcal{O}(1) \). \newline
		S'exécute 1 fois. \newline

        \noindent Ainsi, il est possible de savoir que :
	    \begin{align*}
	       T(n) &= 4*(\mathcal{O}(1))+\mathcal{O}(log \: n)+8*( \mathcal{O}(1)*\mathcal{O}(log \: n)) + \mathcal{O}(1) \\
	   	   &= \mathcal{O}(13*(1)+9*(log \: n)) \\
	       &= \mathcal{O}(log \: n)
	    \end{align*}
  	\newpage
    \subsection*{b)}
      \noindent Nous observons que \textit{fib1} est la fonction dont la temps d'exécution est le plus long et que la fonction \textit{fib3} possède le temps d'exécution le plus court. Cette différence s'explique par le fait que \( \phi^n \geq n \geq log \: n  \; \; \forall n \in \mathbb{R} \)
    \subsection*{c)}
	  \subsubsection*{Fonction fib1 :}
      \noindent Cette fonction n'utilise pas beaucoup d'espace mémoire puisqu'elle ne fait qu'une comparaison et une addition, cependant le fait qu'elle soit récursive et qu'elle possède un temps d'exécution exponentiel font en sorte qu'elle a besoin de beaucoup plus d'espace mémoire que les 2 autres fonctions. Elle doit garder en mémoire la fonction à chaque fois qu'elle fait appelle à elle-même.
      \subsubsection*{Fonction fib2 :}
      \noindent Cette fonction utilise moins de ressource que \textit{fib3} puisqu'elle possède moins de déclaration de variable que \textit{fib3}.
      \subsubsection*{Fonction fib3 :}
      \noindent Cette fonction utilise moins d'espace mémoire que \textit{fib1} mais plus que \textit{fib2} car cette dernière utilise déclare moins de variable que \textit{fib3}.
    \subsection*{d)}
      \noindent Voici le temps processeur nécessaire pour les valeurs de n suivantes :
      \begin{table}[h]
      	\centering
        \begin{tabular}{|c|c|c|c|}
          \hline
          & \textbf{fib1 (sec)} & \textbf{fib2( sec)} & \textbf{fib3 (sec)} \\ \hline
          \textbf{n=10}      & 0.000003            & 0.000005            & 0.000016            \\ \hline
          \textbf{n=100}     & N/A                 & 0.000006            & 0.000017            \\ \hline
          \textbf{n=1000}    & N/A                 & 0.000014            & 0.000019            \\ \hline
          \textbf{n=10000}   & N/A                 & 0.000197            & 0.000019            \\ \hline
          \textbf{n=100000}  & N/A                 & 0.001976            & 0.000020            \\ \hline
          \textbf{n=1000000} & N/A                 & 0.020925            & 0.000017*(Devrait être plus élevée)            \\ \hline
        \end{tabular}
      \end{table}
      \newline
      \textbf{Note :} N/A = Beaucoup trop long.
\end{document}
