\documentclass[12pt]{article}

\usepackage{vmargin}
\usepackage{setspace}
\usepackage[ruled, linesnumbered, french, onelanguage]{algorithm2e}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{enumitem}

\title{Devoir 1}
\author{Jérémy Bouchard}
\date{\today}

\begin{document}

  \begin{titlepage}
    \doublespacing
    \centering

    UNIVERSITÉ DU QUÉBEC À CHICOUTIMI \\

    \vspace{4.7cm}

    DEVOIR 1 \\

    \vspace{4.7cm}

    PAR \\
    JÉRÉMY BOUCHARD (BOUJ08019605) \\
    ALEXANDRE LAROUCHE (LARA04119705) \\
    JEAN-PHILIPPE SAVARD (SAVJ04079609) \\
    ALEXIS VALOTAIRE (VALA) \\

    \vspace{4.7cm}

    DEVOIR PRÉSENTÉ À \\
    M. FRANÇOIS LEMIEUX \\
    DANS LE CADRE DU COURS D'ALGORITHMIQUE (8INF433)

  \end{titlepage}

  \newpage

  \newpage

  \pagenumbering{arabic}
  \onehalfspacing

  \section*{Question 1}

    \begin{enumerate}[label=(\alph*)]
      \item \[ 4 ^ {log_2 n} \in \omega 4 ^ {log_4 n} \]
      \item \[ (n + 1) ^ {2} \in \Theta (n ^ 2) \]
      \item \[ 2 ^ {n + 1} \in \Theta (2 ^ n) \]
      \item \[ n! \in o (n + 1)! \]
      \item \[ 2 ^ n \in \Theta (4 ^ {n / 2}) \]
      \item \[ n*log_2(n) \in o (n ^ 2 - n) \]
      \item \[ (log_2(n)) ^ 2 \in \omega (log_2(n^2)) \]
      \item \[ {1 \over 2} ^ {n} \in o (1) \]
      \item \[ 2^{100} \in \Theta(2) \]
      \item \[ log_2(n^2) \in \Theta log_4(n) \]
    \end{enumerate}

  \newpage

  \section*{Question 2}
  \subsection*{(a)}

    Il est possible d'exprimer le pseudo-code de l'algorithme décrit dans
    l'énoncé de la question 2. Il est également possible de constater qu'il
    s'agit de l'algorithme du tri par selection. Celui-ci ce décrit de cette
    façon : \newline

    \begin{algorithm}[H]
      \KwData{\( T[1 \cdot\cdot\cdot  n] \)}
      \KwResult{\( T[1 \cdot\cdot\cdot  n] \) (Trié)}
        \For{\( j \gets 1 $ \KwTo $ n - 1 \)}{
          \( petit \gets j \)\\
          \For{\( i \gets j + 1 \) \KwTo \( n \)}{
            \If{\( T[i] < T[petit]\ \)}{
              \( petit \gets i \)\
            }
          }
          \( T[j] \leftrightarrow T[petit] \)
        }
      \caption{Pseudo-code du numéro 2}
    \end{algorithm}

  \subsection*{(b)}

    Il est possible de calculer le temps d'exécution de cette algorithme
    facilement. En effet, pour chaque élément du tableau il est necessaire de
    parcourir le reste du tableau moins les éléments déjà triés. Donc, pour la
    première itération, il est nécessaire de réaliser \( (n - 1) \)
    comparaisons. Pour la deuxième itération, cela sera \( (n - 2) \) itérations
    et ainsi de suite jusqu'à ce qu'il ne reste que une seule valeur à trier. Il
    est donc possible de formaliser le temps d'exécution de cette manière :

    \[ (n - 1) + (n - 2) + (n - 3) + ... + 1 = \sum _ {i=1} ^ {n - 1} i \]

    \noindent Il ne reste qu'à trouver l'ordre de
    \( \sum _ {i=1} ^ {n - 1} i \). \newpage

    \begin{proof}[Temps d'exécution de l'algorithme de tri]
      \begin{align*}
        S   &= \sum _ {i=1} ^ {n - 1} i \\
            &= (n - 1) + (n - 2) + (n - 3) + ... + 1 \\
        2S  &= (n - 1) + (n - 2) + (n - 3) + ... + 1 \\
            &\qquad\,\, + 1 \qquad\;\:\, + 2 \qquad\;\:\, + 3 \;+ ... + (n - 1) \\
            &= \underbrace{(n + n + n + ... + n)}_\textrm{\( (n - 1) \) fois} \\
            &= (n - 1)(n) \\
        S   &= \frac{n(n - 1)}{2} \\
            &= \frac{1}{2}n^2 - \frac{1}{2}n
      \end{align*}
      \( D'o\grave{u} \ \mathcal{O}(n^2) \)
    \end{proof}

  \newpage

  \section*{Question 3}
  Pour prouver cette égalité, il est nécessaire d'utiliser la definition
  formelle de la notation grand \( \mathcal{O} \). \newline

  \noindent Pour prouver que
  \( \mathcal{O}({max\{f(n), g(n)\}}) = \mathcal{O}(f(n) + g(n)) \), on doit
  donc prouver que n'importe quelle fonction apartenant à un ensemble appartient
  aussi à l'autre ensemble. \\

  \begin{proof}[Preuve]
    \noindent \\ Notons une fonction : \[ S(n) \in \mathcal{O}(f(n) + g(n)) \] \\

    \noindent Notons aussi les deux relations suivantes :
    \[ f(n) + g(n) = min\{f(n), g(n)\} + max\{f(n), g(n)\} \]
    \[ max\{f(n), g(n)\} \leq f(n) + g(n) \leq 2 * max\{f(n), g(n)\} \] \\

    \noindent Il est possible d'utiliser la définition formelle pour écrire :
    \begin{align*}
      | S(n) |  &\leq c * (f(n) + g(n)), n > n_1 \\
                &\leq c * 2 * max\{f(n), g(n)\}, n > n_1 \\
                &\leq k * max\{f(n), g(n)\}, n > n_1 \\
                & n_1 = 1, k = 2 * c
    \end{align*}

    \noindent D'où :
    \( S(n) \in \mathcal{O}({max\{f(n), g(n)\}})\)
  \end{proof}

  \newpage

  \section*{Question 4}
	\subsection*{Temps d'exécution}
    Pour déterminer le temps d'exécution de l'algorithme tel qu'écrit dans l'
    énoncé, il faut avant tout analyser ligne par ligne le pseudo-code. Voici
    donc l'analyse ligne par ligne. \newline

    Ligne 1 : \( d = 0 \) \newline
    Une affection en informatique se fait en un temps constant
    \( \mathcal{O}(1) \). \newline

    Ligne 2 : tant que \( (X > Y) \) faire \( \{ ... \} \) \newline
    L'analyse de cette ligne est beaucoup plus difficile à faire, puisque nous
	  ne savons pas comment la condition sortie est modifiée. Nous le saurons au
    moment de l'analyse du contenu de la boucle. \newline

  	Avec l'analyse du contenu de la boucle, on découvre qu'elle est exécutée
  	\( n \) fois, basée sur la différence de \( X \) et \( Y \). Ainsi, on peut
    conclure qu'elle est exécutée en un temps linéaire \( \mathcal{O}(n) \).
    \newline

    Ligne 3 : \( Soustraction(X, Y) \) \newline
    Il est mentionné dans l'énoncé que cette fonction est exécuté en un temps
	  linéaire \( \mathcal{O}(n) \). \newline

    Ligne 4 : \( d = d + 1 \) \newline
    Une affection et une addition en informatique se font en un temps constant
    \( \mathcal{O}(1) \). \newline

    Ligne 5 : return \( d \) \newline
  	Un retour en informatique se fait en un temps constant
    \( \mathcal{O}(1) \). \newline

    \noindent Ainsi, il est possible de savoir que :
    \begin{enumerate}
      \item Le temps d'exécution du contenu de la boucle est de \( n + 1 \);
      \item Le contenu de la boucle est exécuté `n` fois, donc \( n(n + 1) \);
      \item Le reste de l'algorithme est en temps constant, donc
       \( n(n + 1) + 1 \).
    \end{enumerate}

    \noindent En distribuant le tout, nous avons \( n ^ 2 + n + 1 \). Donc le
    temps d'exécution est de l'ordre de \( \mathcal{O}(n^2) \).

  \subsection*{Efficacité de l'algorithme}
   	Est-ce que l'algorithme est efficace? La réponse est non. En effet, avec
   	l'analyse du temps d'exécution fait précédement, nous avons déterminé
   	que dans le pire des cas, le temps d'exécution est de l'ordre
   	de \( \mathcal{O}(n^2) \). \newline

   	\noindent Bien qu'un algorithme de cet ordre est généralement acceptable,
   	il est mentionné dans l'énoncé que les variables X et Y sont de grands
   	entiers. On peut conclure que le pire des cas se produira relativement
   	souvent à l'exécution de l'algorithme, ce qui n'est pas vraiment
    acceptable. \newline

    \noindent Pour améliorer l'algorithme, il faudrait que la fonction
    \( Soustraction(X, Y) \) soit exectuable dans un temps constant au lieu d'un
    temps linéaire, ce qui réduirait le temps d'exécution dans l'ordre de
    \( \mathcal{O}(n) \), ce qui serait beaucoup plus acceptable avec de grandes
    valeurs d'entiers. Il serait possible de le faire en remplacant la ligne
    avec \( X - Y \).

  \newpage

  \section*{Question 5}

  \newpage

\end{document}
